**********************************************************************************************

pp.command("/whoscomingtest", async ({ ack, body, client }) => {
    await ack();

    const channelId = body.channel_id;

    // Attempt to join channel
    // try {
    //     await client.conversations.join({ channel: channelId });
    // } catch (err) {
    //     if (err.data?.error !== "method_not_supported_for_channel_type") {
    //         console.warn(`Could not join channel ${channelId}: ${err.data?.error}`);
    //     }
    // }
        
    try {
        await client.views.open({
            trigger_id: body.trigger_id,
            view: {
                type: "modal",
                callback_id: "whoscoming_modal",
                private_metadata: channelId,
                title: { type: "plain_text", text: "Meeting Poll" },
                submit: { type: "plain_text", text: "Create" },
                close: { type: "plain_text", text: "Cancel" },
                blocks: [
                    {
                        type: "input",
                        block_id: "date_block",
                        label: { type: "plain_text", text: "Select meeting date" },
                        element: {
                            type: "datepicker",
                            action_id: "meeting_date",
                            placeholder: { type: "plain_text", text: "Pick a date" }
                        }
                    },
                    // {
                        //   type: "input",
                        //   block_id: "channel_block",
                        //   optional: true,
                        //   label: { type: "plain_text", text: "Choose channel (optional)" },
                        //   element: {
                            //     type: "conversations_select",
                            //     action_id: "poll_channel",
                            //     default_to_current_conversation: true
                            //   }
                        // }
                ]
            }
        });
    } catch (err) {
        console.error("Error opening modal:", err);
    }
});

app.view("whoscoming_modal", async ({ ack, body, view, client }) => {
    await ack();


    const dateInput = view.state.values.date_block.meeting_date.selected_date;
    //console.log("*****************************************************************\n\n\n", dateInput, "\n\n\n*****************************************************************")
    const channelId = body.view.private_metadata;
    const safeDate = formatSlackDateToDateString(dateInput);

    try {
        // // Attempt to join channel
        

        // Prevent duplicates
        const alreadyExists = await findDuplicateMeeting(channelId, dateInput);

        if (alreadyExists) {
            await client.chat.postMessage({
                channel: body.user.id,
                text: `A meeting poll for *${safeDate}* already exists in <#${channelId}>.`
            });
            return;
        }

        // Post the poll
        const pollMsg = await client.chat.postMessage({
            channel: channelId,
            text: `<!channel> Who is going to the meeting on *${safeDate}*?\nReact with:  ‚úÖ yes   ‚ùå no`,
        });

        // Add reactions
        await client.reactions.add({
            channel: channelId,
            timestamp: pollMsg.ts,
            name: "white_check_mark"
        });

        await client.reactions.add({
            channel: channelId,
            timestamp: pollMsg.ts,
            name: "x"
        });

        // Save poll to JSON
        await addMeeting(channelId, pollMsg.ts, dateInput);

        //saveMeetings(meetings);

        // DM user confirmation
        await client.chat.postMessage({
            channel: body.user.id,
            text: `Poll created for *${dateInput}*\nPosted in <#${channelId}>`
        });

    } catch (error) {
        console.error("Error creating poll:", error);
    }
});

app.command("/meetingreporttest", async ({ command, ack, client }) => {
    console.log("received!!")
    await ack();
    console.log("hello!!")
    const channelId = command.channel_id;
    const channelMeetings = (await getMeetingWithTS(channelId))
        .sort((a, b) => new Date(b.date) - new Date(a.date));

    //console.log("****\n\n\n", channelMeetings, "\n\n\n****")

    if (!channelMeetings.length) {
        await client.chat.postEphemeral({
        channel: channelId,
        user: command.user_id,
        text: "There are no meeting polls saved in this channel.",
    });

    return;
    }

    // Build dropdown options
    const options = channelMeetings.map(m => ({
        text: {
            type: "plain_text",
            text: new Date(m.date).toDateString(),
        },
        value: m.ts, // IMPORTANT: store timestamp, not date
    }));

    await client.views.open({
        trigger_id: command.trigger_id,
        view: {
            type: "modal",
            callback_id: "meetingreport_modal",
            private_metadata: channelId,
            title: { type: "plain_text", text: "Meeting Report" },
            submit: { type: "plain_text", text: "View" },
            close: { type: "plain_text", text: "Cancel" },
            blocks: [
                {
                type: "input",
                block_id: "meeting_block",
                label: { type: "plain_text", text: "Select a meeting" },
                element: {
                    type: "static_select",
                    action_id: "meeting_select",
                    options,
                },
                },
            ],
        },
    });
});

app.view("meetingreport_modal", async ({ ack, body, view, client }) => {
    await ack();

    const channelId = view.private_metadata;
    const userId = body.user.id;

    const selectedTs = view.state.values.meeting_block.meeting_select.selected_option.value;

    const channelMeetings = await getMeetingWithTS(channelId);
    const meeting = channelMeetings.find(m => m.ts === selectedTs);

    if (!meeting) {
        await client.chat.postEphemeral({
            channel: channelId,
            user: userId,
            text: "‚ùå Meeting not found.",
        });
        return;
    }

    const auth = await client.auth.test();
    const botUserId = auth.user_id;

    const response = await client.reactions.get({
        channel: channelId,
        timestamp: meeting.ts,
    });

    const reactions = response.message.reactions || [];
    const yesReaction = reactions.find(r => r.name === "white_check_mark");
    const noReaction = reactions.find(r => r.name === "x");

    const yesUsers = yesReaction
        ? yesReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
        : [];

    const noUsers = noReaction
        ? noReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
        : [];

    await client.chat.postEphemeral({
        channel: channelId,
        user: userId,
        text:
            `*Meeting Report for ${new Date(meeting.date).toDateString()}*\n` +
            `‚úÖ Coming: ${yesUsers.length ? yesUsers.join(", ") : "None"}\n` +
            `‚ùå Not coming: ${noUsers.length ? noUsers.join(", ") : "None"}`,
    });
});

app.command("/addmember", async ({ ack, command, client }) => {
    await ack();

    await client.views.open({
        trigger_id: command.trigger_id,
        view: {
            type: "modal",
            private_metadata: command.user_id,
            callback_id: "addMember_modal",
            title: { type: "plain_text", text: "Pick a User" },
            submit: { type: "plain_text", text: "Select" },
            close: { type: "plain_text", text: "Cancel" },
            blocks: [
            {
                type: "input",
                block_id: "users_block",
                label: { type: "plain_text", text: "Choose a user" },
                element: {
                    type: "multi_users_select",
                    action_id: "selected_users",
                    placeholder: {
                        type: "plain_text",
                        text: "Search for a user",
                    },
                },
            },
            {
                type: "input",
                block_id: "channel_block",
                label: { type: "plain_text", text: "Choose channel (channels start with #)" },
                element: {
                    type: "conversations_select",
                    action_id: "poll_channel",
                    default_to_current_conversation: true
                }
            }
            ],
        },
    });
});

app.view("addMember_modal", async ({ack, body, view, client}) => {
    await ack();

    const userId = view.state.values.users_block.selected_users.selected_users;

    const channelID = view.state.values.channel_block.poll_channel.selected_conversation;

    //console.log("****\n\n\n", channelID, "\n", userId, "\n\n\n****")

    for (const uId of userId){
        
        try {
            // Add the user to your system
            await addUser(channelID, uId);

            // Send confirmation to the person who submitted the modal
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: body.view.private_metadata, // modal owner
                    text: `<@${uId}> has been added as a member of <#${channelID}>`,
                });
            } catch (error) {
                console.error("***\n\nError posting the creation of a new member:", error, "\n\n***");
            }
        } catch(error) {
        console.error("***\n\nError creating adding member:", error, "\n\n***");
        }
    }
});

app.command("/removemember", async ({ ack, command, client }) => {
    await ack();

    await client.views.open({
        trigger_id: command.trigger_id,
        view: {
            type: "modal",
            private_metadata: command.user_id,
            callback_id: "removeMember_modal",
            title: { type: "plain_text", text: "Pick a User" },
            submit: { type: "plain_text", text: "Select" },
            close: { type: "plain_text", text: "Cancel" },
            blocks: [
            {
                type: "input",
                block_id: "users_block",
                label: { type: "plain_text", text: "Choose a user" },
                element: {
                    type: "multi_users_select",
                    action_id: "selected_users",
                    placeholder: {
                        type: "plain_text",
                        text: "Search for a user",
                    },
                },
            },
            {
                type: "input",
                block_id: "channel_block",
                label: { type: "plain_text", text: "Choose channel (channels start with #)" },
                element: {
                    type: "conversations_select",
                    action_id: "poll_channel",
                    default_to_current_conversation: true
                }
            }
            ],
        },
    });
});

app.view("removeMember_modal", async ({ack, body, view, client}) => {
    await ack();

    const userId = view.state.values.users_block.selected_users.selected_users;

    const channelID = view.state.values.channel_block.poll_channel.selected_conversation;

    //console.log("****\n\n\n", channelID, "\n", userId, "\n\n\n****")

    for (const uId of userId){
        
        try {
            // Add the user to your system
            await removeUser(channelID, uId);

            // Send confirmation to the person who submitted the modal
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: body.view.private_metadata, // modal owner
                    text: `<@${uId}> has been removed as a member of <#${channelID}>`,
                });
            } catch (error) {
                console.error("***\n\nError posting the removal of a  member:", error, "\n\n***");
            }
        } catch(error) {
        console.error("***\n\nError removing member:", error, "\n\n***");
        }
    }
});

app.command("/pingsubteam", async ({ack, command, client }) => {
    await ack();

    const message     =    command.text.trim();
    const channelID   =    command.channel_id;
    const sender      =    command.user_id;
    const subteam     =    await getUsers(channelID);
    
    console.log("****\n\n\n", message, "\n", channelID, "\n", sender, "\n", subteam, "\n", "\n\n\n****")
    try {
        for (const userID of subteam){
            //const userID = userObj.userID;

            //Invite the user if they're not in the channel
            try {
                await client.conversations.invite({
                channel: channelID,
                users: userID.userID
                });
            } catch (err) {
                if (err.data?.error !== "already_in_channel") {
                    console.error(`Error inviting user ${userID}:`, err.data?.error);
                    continue; // skip this user if invite fails
                }
            }

            //send ping to each user induvidually
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: userID.userID, // modal owner
                    text: `<@${userID.userID}>`,
                });
            } catch (error) {
                console.error("***\n\nError pinging member:", error, "\n\n***");
            }
        }

        const res = await client.users.info({ user: sender });
        const user = res.user;
        const displayName = user.profile.display_name || user.real_name || "Unknown User";
        const avatarUrl = user.profile.image_192 || user.profile.image_72;

        await client.chat.postMessage({
                    channel: channelID,
                    text: message,
                    username: displayName,
                    icon_url: avatarUrl
        });


    } catch(error) {
       console.error("Error pinging subteam:", error);
    }
});

app.command("/help", async ({ ack, command, client }) => {
    await ack();
    const helpText = commands.map(c => `‚Ä¢ \`${c.name}\` ‚Äî ${c.desc}`).join("\n");

    await client.chat.postEphemeral({
        channel: command.channel_id,
        user: command.user_id,
        text: `*Available Commands:*\n${helpText}`,
    });
});

**********************************************************************************************

//clickup API stuff
import dotenv from "dotenv"
import { readFile,writeFile } from 'node:fs/promises';

dotenv.config()


const url = "https://api.clickup.com/api/v2/team/9011117189/task";
const options = {
    method: 'GET', 
    headers: {
        accept: 'application/json',
        Authorization: process.env.CLICKUP_API_KEY

    }};


function cacheClickUpData() {
    fetch(url, options)
        .then(res => res.json())
        .then(json => {
            console.log('Data saved');
            writeFile('./temp.json', JSON.stringify(json, null, 2));
        })
        .catch(err => console.error(err)); 
}

const data = await readFile('./temp.json', 'utf8');
const json = JSON.parse(data);

console.log(json);

//Command to create poll
// app.command("/whoscoming", async ({ command, ack, client }) => {
    //   await ack();

    //   const dateInput = command.text.trim();
    //   const channelId = command.channel_id;

    //   try {

        //     //try to join channel if not in (so you dont have to invite every time)
        //     try {
            //       await client.conversations.join({ channel: channelId });
            //       console.log(`Joined channel ${channelId}`);
            //     } catch (joinError) {
                //       if (joinError.data?.error !== "method_not_supported_for_channel_type") {
                    //         console.warn(`Could not auto-join channel ${channelId}:`, joinError.data?.error);
                    //       }
                //     }

        //     const meetings = loadMeetings();

        //     // Ensure channel entry exists
        //     if (!meetings[channelId]) meetings[channelId] = [];

        //     const newDate = new Date(dateInput);

        //     //Check for existing meeting with same date
        //     const existingMeeting = meetings[channelId].find(
            //       (m) => new Date(m.date).toDateString() === newDate.toDateString()
            //     );

        //     if (existingMeeting) {
            //       await client.chat.postEphemeral({
                //         channel: channelId,
                //         user: command.user_id,
                //         text: `A meeting poll already exists for *${dateInput}*`,
                //       });
            //       console.log(1)
            //       return;
            //     }
        //       const showDate = new Date(dateInput).toDateString()
        //       // 1. Post poll message
        //       const result = await client.chat.postMessage({
            //         channel: channelId,
            //         text: `<!channel> Who is going to the meeting on *${showDate}*? React with ‚úÖ or ‚ùå`,
            //       });

        //       // 2. Add reactions
        //       await client.reactions.add({ channel: result.channel, timestamp: result.ts, name: "white_check_mark" });
        //       await client.reactions.add({ channel: result.channel, timestamp: result.ts, name: "x" });

        //       // 3. Save poll to JSON
        //       if (!meetings[channelId]) meetings[channelId] = [];

        //       meetings[channelId].push({
            //         ts: result.ts,
            //         date: dateInput,
            //       });
        //       saveMeetings(meetings);


        //       await client.chat.postEphemeral({
            //         channel: channelId,
            //         user: command.user_id,
            //         text: `Meeting poll created and saved for *${dateInput}*`,
            //       });
        //   }
    //   catch (error) {
        //     console.error("Error posting testreport:", error);
        //   }
    // });




    // Schedule the daily report at 9:30 PM

// cron.schedule('28 20 * * *', async () => {
    //   console.log('9:30 PM - Triggering daily report...');
    //   await sendDailyReport();
    // }, {
        //   timezone: "America/New_York" // Change to your timezone
        // });

// // message leads asking them for photos and videos, add to a Google drive folder
// cron.schedule('17 00 * * *', async() => {
    //   await pm(process.env.SLACK_USER_IDS, `Please add any photos or videos from todays meeting to <${process.env.GOOGLE_DRIVE_LINK}| google drive>`);
    // },{
        //   timezone: "America/New_York" //timezone
        // });


// Function to format and send the daily report
async function sendDailyReport() {
    try {
        const reportData = await generateDailyReport();

        if (reportData.status === 'error') {
            // Send error message
            await app.client.chat.postMessage({
                token: process.env.SLACK_BOT_TOKEN,
                channel: DAILY_REPORT_CHANNEL,
                text: '‚ö†Ô∏è Daily Report - Service Issue',
                blocks: [
                    {
                        type: 'header',
                        text: {
                            type: 'plain_text',
                            text: '‚ö†Ô∏è Daily Report - Service Issue'
                        }
                    },
                    {
                        type: 'section',
                        text: {
                            type: 'mrkdwn',
                            text: `*Time:* ${reportData.timestamp}\n*Status:* ${reportData.message}`
                        }
                    }
                ]
            });
            return;
        }

        // Create rich formatted message with both API results
        const blocks = [
            {
                type: 'header',
                text: {
                    type: 'plain_text',
                    text: 'üìä Daily Data Report - 9:30 PM Update'
                }
            },
            {
                type: 'context',
                elements: [
                    {
                        type: 'mrkdwn',
                        text: `üìÖ Generated on ${reportData.timestamp}`
                    }
                ]
            },
            {
                type: 'divider'
            }
        ];


        // Add AI Analysis section
        blocks.push({
            type: 'section',
            text: {
                type: 'mrkdwn',
                text: `ü§ñ *AI Analysis (${reportData.aiAnalysis.model})*\n${reportData.aiAnalysis.analysis}`
            }
        });



        // Add footer
        blocks.push(
            {
                type: 'divider'
            },
            {
                type: 'context',
                elements: [
                    {
                        type: 'mrkdwn',
                        text: 'Automated report Generated every day at 9:30 PM'
                    }
                ]
            }
        );



        // Send the formatted message
        await app.client.chat.postMessage({
            token: process.env.SLACK_BOT_TOKEN,
            channel: DAILY_REPORT_CHANNEL,
            text: 'üìä Daily Data Report - 9:30 PM Update',
            blocks: blocks
        });

        console.log('‚úÖ Daily report sent successfully to Slack');

    } catch (error) {
        console.error('‚ùå Error sending daily report:', error);

        // Send fallback message
        await app.client.chat.postMessage({
            token: process.env.SLACK_BOT_TOKEN,
            channel: DAILY_REPORT_CHANNEL,
            text: '‚ö†Ô∏è Daily report failed to send. Please check the bot logs.'
        });
    }
}



app.command("/clearmeetings", async ({ command, ack, client }) => {
    await ack();

    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        if (!meetings[channelId]) meetings[channelId] = [];

        meetings[channelId] = [];
        saveMeetings(meetings);
    } catch (error) {
        console.error("Error clearing meetings:", error);
    }
});




app.command("/meetingreport", async ({ command, ack, client }) => {
    await ack();

    const dateInput = command.text.trim();
    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        const channelMeetings = meetings[channelId] || [];

        //No date provided ‚Üí show available poll dates
        if (!dateInput) {
            if (channelMeetings.length === 0) {
                await client.chat.postEphemeral({
                    channel: channelId,
                    user: command.user_id,
                    text: `There are no meeting polls saved in this channel.`,
                });
                return;
            }

            const datesList = channelMeetings.map(m => `‚Ä¢ ${m.date}`).join("\n");

            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `*Available meeting reports in this channel:*\n${datesList}\n\nRun \`/meetingreport <date>\` to view one.`,
            });

            return;
        }

        //Date provided ‚Üí find that poll
        const meeting = channelMeetings.find(m => m.date === dateInput);
        if (!meeting) {
            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `‚ùå No meeting poll found for *${dateInput}* in this channel.`,
            });
            return;
        }

        const auth = await client.auth.test();
        const botUserId = auth.user_id;

        const response = await client.reactions.get({
            channel: channelId,
            timestamp: meeting.ts,
        });

        const reactions = response.message.reactions || [];
        const yesReaction = reactions.find(r => r.name === "white_check_mark");
        const noReaction = reactions.find(r => r.name === "x");

        const yesUsers = yesReaction
            ? yesReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        const noUsers = noReaction
            ? noReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        client.chat.postEphemeral({
            channel: channelId,
            user: command.user_id,
            text: `*Meeting Report for ${meeting.date}*\n‚úÖ Coming: ${yesUsers.length ? yesUsers.join(", ") : "None"}\n‚ùå Not coming: ${noUsers.length ? noUsers.join(", ") : "None"}`,
        });

    } catch (error) {
        console.error("Error getting report:", error);
    }
});


app.command("/latestmeeting", async ({ command, ack, client }) => {
    await ack();

    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        const channelMeetings = meetings[channelId] || [];


        let date = new Date(channelMeetings[0].date);;
        let index = 0;
        for(let i = 0; i < channelMeetings.length; i++) {
            let nDate = new Date(channelMeetings[i].date);
            if(nDate > date){
                index = i;
                date = nDate;
            }
        }


        // üìä Date provided ‚Üí find that poll
        const meeting = channelMeetings[index];
        if (!meeting) {
            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `‚ùå No meeting poll found for *${dateInput}* in this channel.`,
            });
            return;
        }

        const auth = await client.auth.test();
        const botUserId = auth.user_id;

        const response = await client.reactions.get({
            channel: channelId,
            timestamp: meeting.ts,
        });

        const reactions = response.message.reactions || [];
        const yesReaction = reactions.find(r => r.name === "white_check_mark");
        const noReaction = reactions.find(r => r.name === "x");

        const yesUsers = yesReaction
            ? yesReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        const noUsers = noReaction
            ? noReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        client.chat.postEphemeral({
            channel: channelId,
            user: command.user_id,
            text: `*Meeting Report for ${meeting.date}*\n‚úÖ Coming: ${yesUsers.length ? yesUsers.join(", ") : "None"}\n‚ùå Not coming: ${noUsers.length ? noUsers.join(", ") : "None"}`,
        });

    } catch (error) {
        console.error("Error getting report:", error);
    }
});

app.command("/addlead", async ({command, ack, client}) => {
    await ack();

    const userID = command.text.trim();
    console.log(userID)
    // Match all user mentions ‚Äî handles both "<@U12345>" and "<@U12345|username>"
    const userMatches = userID.matchAll(/<@([A-Z0-9]+)(?:\|[^>]+)?>/gi);

    // Convert to an array of user IDs
    const mentionedUserIds = Array.from(userMatches, m => m[1]);
    console.log(mentionedUserIds)

    if (mentionedUserIds.length === 0) {
        await client.chat.postEphemeral({
            channel: command.channel_id,
            user: command.user_id,
            text: "Please mention at least one user like `/addlead @username`",
        });
    }

    const channelId = command.channel_id;

    try {

        const leads = loadLeads();

        console.log("\n\n\n1\n\n\n")

        const result = await app.client.users.list();
        const users = result.members;

        for(let id of mentionedUserIds){
            if (!leads[id]) leads[id] = [];

            console.log(id + "\n")
            console.log(leads)
            users.forEach(u => {
                if(id == u.id) {
                    leads[id].push([u.real_name]);
                }  
            })
        }
        saveLeads(leads);
    } catch (error) {
        console.error("Error adding leads:", error);
    }

});


const MEETINGS_FILE = "./meetings.json";
const LEADS_FILE = "./leads.json"

// Utility: load JSON
function loadMeetings() {
    if (!fs.existsSync(MEETINGS_FILE)) return {};
    const data = fs.readFileSync(MEETINGS_FILE);
    return JSON.parse(data);
}

// Utility: save JSON
function saveMeetings(meetings) {
    fs.writeFileSync(MEETINGS_FILE, JSON.stringify(meetings, null, 2));
}

// Utility: load JSON
function loadLeads() {
    if (!fs.existsSync(LEADS_FILE)) return {};
    const data = fs.readFileSync(LEADS_FILE);
    return JSON.parse(data);
}

// Utility: save JSON
function saveLeads(leads) {
    fs.writeFileSync(LEADS_FILE, JSON.stringify(leads, null, 2));
}




**********************************************************************

app.command("/whoscomingtest", async ({ ack, body, client }) => {
    await ack();

    const channelId = body.channel_id;
    const idem = `whoscoming:${body.trigger_id}`;

    enqueue(channelId, async () => {
        await runOnce(idem, async () => {
            await client.views.open({
                trigger_id: body.trigger_id,
                view: {
                    type: "modal",
                    callback_id: "whoscoming_modal",
                    private_metadata: channelId,
                    title: { type: "plain_text", text: "Meeting Poll" },
                    submit: { type: "plain_text", text: "Create" },
                    close: { type: "plain_text", text: "Cancel" },
                    blocks: [
                        {
                            type: "input",
                            block_id: "date_block",
                            label: { type: "plain_text", text: "Select meeting date" },
                            element: {
                                type: "datepicker",
                                action_id: "meeting_date",
                            },
                        },
                    ],
                },
            });
        });
    });
});


app.view("whoscoming_modal", async ({ ack, body, view, client }) => {
    await ack();

    const channelId = view.private_metadata;
    const idem = `whoscoming_view:${body.view.id}`;

    enqueue(channelId, async () => {
        await runOnce(idem, async () => {
            const dateInput =
                view.state.values.date_block.meeting_date.selected_date;

            const safeDate = formatSlackDateToDateString(dateInput);

            const exists = await findDuplicateMeeting(channelId, dateInput);
            if (exists) {
                await client.chat.postMessage({
                    channel: body.user.id,
                    text: `A meeting poll for *${safeDate}* already exists in <#${channelId}>.`,
                });
                return;
            }

            const poll = await client.chat.postMessage({
                channel: channelId,
                text: `<!channel> Who is going to the meeting on *${safeDate}*?\nReact with ‚úÖ or ‚ùå`,
            });

            await client.reactions.add({
                channel: channelId,
                timestamp: poll.ts,
                name: "white_check_mark",
            });

            await client.reactions.add({
                channel: channelId,
                timestamp: poll.ts,
                name: "x",
            });

            await addMeeting(channelId, poll.ts, dateInput);

            await client.chat.postMessage({
                channel: body.user.id,
                text: `Poll created for *${safeDate}* in <#${channelId}>`,
            });
        });
    });
});


app.command("/meetingreporttest", async ({ ack, command, client }) => {
    await ack();

    const channelId = command.channel_id;
    const idem = `meetingreport:${command.trigger_id}`;

    enqueue(channelId, async () => {
        await runOnce(idem, async () => {
            const meetings = (await getMeetingWithTS(channelId))
                .sort((a, b) => new Date(b.date) - new Date(a.date));

            if (!meetings.length) {
                await client.chat.postEphemeral({
                    channel: channelId,
                    user: command.user_id,
                    text: "There are no meeting polls in this channel.",
                });
                return;
            }

            const options = meetings.map(m => ({
                text: {
                    type: "plain_text",
                    text: new Date(m.date).toDateString(),
                },
                value: m.ts,
            }));

            await client.views.open({
                trigger_id: command.trigger_id,
                view: {
                    type: "modal",
                    callback_id: "meetingreport_modal",
                    private_metadata: channelId,
                    title: { type: "plain_text", text: "Meeting Report" },
                    submit: { type: "plain_text", text: "View" },
                    close: { type: "plain_text", text: "Cancel" },
                    blocks: [
                        {
                            type: "input",
                            block_id: "meeting_block",
                            label: { type: "plain_text", text: "Select a meeting" },
                            element: {
                                type: "static_select",
                                action_id: "meeting_select",
                                options,
                            },
                        },
                    ],
                },
            });
        });
    });
});

app.view("meetingreport_modal", async ({ ack, body, view, client }) => {
    await ack();

    const channelId = view.private_metadata;
    const userId = body.user.id;
    const ts =
        view.state.values.meeting_block.meeting_select.selected_option.value;

    enqueue(channelId, async () => {
        const meetings = await getMeetingWithTS(channelId);
        const meeting = meetings.find(m => m.ts === ts);
        if (!meeting) return;

        const auth = await client.auth.test();
        const botId = auth.user_id;

        const res = await client.reactions.get({
            channel: channelId,
            timestamp: meeting.ts,
        });

        const reactions = res.message.reactions || [];
        const yes = reactions.find(r => r.name === "white_check_mark");
        const no = reactions.find(r => r.name === "x");

        const yesUsers = yes
            ? yes.users.filter(u => u !== botId).map(u => `<@${u}>`)
            : [];

        const noUsers = no
            ? no.users.filter(u => u !== botId).map(u => `<@${u}>`)
            : [];

        await client.chat.postEphemeral({
            channel: channelId,
            user: userId,
            text:
                `*Meeting Report for ${new Date(meeting.date).toDateString()}*\n` +
                `‚úÖ Coming: ${yesUsers.join(", ") || "None"}\n` +
                `‚ùå Not coming: ${noUsers.join(", ") || "None"}`,
        });
    });
});


app.command("/addmember", async ({ ack, command, client }) => {
    await ack();

    enqueue(command.channel_id, async () => {
        await client.views.open({
            trigger_id: command.trigger_id,
            view: {
                type: "modal",
                callback_id: "addMember_modal",
                private_metadata: command.user_id,
                title: { type: "plain_text", text: "Add Members" },
                submit: { type: "plain_text", text: "Add" },
                close: { type: "plain_text", text: "Cancel" },
                blocks: [
                    {
                        type: "input",
                        block_id: "users_block",
                        label: { type: "plain_text", text: "Select users" },
                        element: {
                            type: "multi_users_select",
                            action_id: "users",
                        },
                    },
                    {
                        type: "input",
                        block_id: "channel_block",
                        label: { type: "plain_text", text: "Channel" },
                        element: {
                            type: "conversations_select",
                            action_id: "channel",
                            default_to_current_conversation: true,
                        },
                    },
                ],
            },
        });
    });
});

app.view("addMember_modal", async ({ack, body, view, client}) => {
    await ack();

    const userId = view.state.values.users_block.selected_users.selected_users;

    const channelID = view.state.values.channel_block.poll_channel.selected_conversation;

    //console.log("****\n\n\n", channelID, "\n", userId, "\n\n\n****")

    for (const uId of userId){
        
        try {
            // Add the user to your system
            await addUser(channelID, uId);

            // Send confirmation to the person who submitted the modal
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: body.view.private_metadata, // modal owner
                    text: `<@${uId}> has been added as a member of <#${channelID}>`,
                });
            } catch (error) {
                console.error("***\n\nError posting the creation of a new member:", error, "\n\n***");
            }
        } catch(error) {
        console.error("***\n\nError creating adding member:", error, "\n\n***");
        }
    }
});



**********************************************************************


app.command("/showroles", async({ack, command, client}) => {
    await ack();

    const PostchannelID   =    command.channel_id;
    const subteam     =    await getUsers(PostchannelID);
    const sender      =    command.user_id;
    const message = [];

    try {
        for (const userID of subteam){
            //console.log(userID.userID, "*************************")
            const roles = await getUserRoles(userID.userID);
            const res = await client.users.info({ user: userID.userID });
            const user = res.user;
            const displayName = user.profile.display_name || user.real_name || "Unknown User";
            const avatarUrl = user.profile.image_192 || user.profile.image_72;

            let roleString = ``;

            for(const channelID of roles){
                roleString += `<#${channelID.channelID}>\n`;
            }

            message.push(
                {
                "type": "divider"
                },
                {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": `*${displayName}*\nRoles:\n${roleString}`
                    },
                "accessory": {
                    "type": "image",
                    "image_url": avatarUrl,
                    "alt_text": "avatar thumbnail"
                    }
                },
            )
        }
         message.push(
                {
                "type": "divider"
                },
            )
        await app.client.chat.postEphemeral({
            user:sender,
            channel: PostchannelID,
            text: "Test message",
            blocks: message
        });
    } catch(err) {
        console.error("Error with Show Roles:\n", err);
    }       
});

app.command("/addmember", async ({ ack, command, client }) => {
    await ack();

    await client.views.open({
        trigger_id: command.trigger_id,
        view: {
            type: "modal",
            private_metadata: command.user_id,
            callback_id: "addMember_modal",
            title: { type: "plain_text", text: "Pick a User" },
            submit: { type: "plain_text", text: "Select" },
            close: { type: "plain_text", text: "Cancel" },
            blocks: [
            {
                type: "input",
                block_id: "users_block",
                label: { type: "plain_text", text: "Choose a user" },
                element: {
                    type: "multi_users_select",
                    action_id: "selected_users",
                    placeholder: {
                        type: "plain_text",
                        text: "Search for a user",
                    },
                },
            },
            {
                type: "input",
                block_id: "channel_block",
                label: { type: "plain_text", text: "Choose channel (channels start with #)" },
                element: {
                    type: "conversations_select",
                    action_id: "poll_channel",
                    default_to_current_conversation: true
                }
            }
            ],
        },
    });
});

app.view("addMember_modal", async ({ack, body, view, client}) => {
    await ack();

    const userId = view.state.values.users_block.selected_users.selected_users;

    const channelID = view.state.values.channel_block.poll_channel.selected_conversation;

    //console.log("****\n\n\n", channelID, "\n", userId, "\n\n\n****")

    for (const uId of userId){
        
        try {
            // Add the user to your system
            await addUser(channelID, uId);

            // Send confirmation to the person who submitted the modal
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: body.view.private_metadata, // modal owner
                    text: `<@${uId}> has been added as a member of <#${channelID}>`,
                });
            } catch (error) {
                console.error("***\n\nError posting the creation of a new member:", error, "\n\n***");
            }
        } catch(error) {
        console.error("***\n\nError creating adding member:", error, "\n\n***");
        }
    }
});

app.command("/removemember", async ({ ack, command, client }) => {
    await ack();

    await client.views.open({
        trigger_id: command.trigger_id,
        view: {
            type: "modal",
            private_metadata: command.user_id,
            callback_id: "removeMember_modal",
            title: { type: "plain_text", text: "Pick a User" },
            submit: { type: "plain_text", text: "Select" },
            close: { type: "plain_text", text: "Cancel" },
            blocks: [
            {
                type: "input",
                block_id: "users_block",
                label: { type: "plain_text", text: "Choose a user" },
                element: {
                    type: "multi_users_select",
                    action_id: "selected_users",
                    placeholder: {
                        type: "plain_text",
                        text: "Search for a user",
                    },
                },
            },
            {
                type: "input",
                block_id: "channel_block",
                label: { type: "plain_text", text: "Choose channel (channels start with #)" },
                element: {
                    type: "conversations_select",
                    action_id: "poll_channel",
                    default_to_current_conversation: true
                }
            }
            ],
        },
    });
});

app.view("removeMember_modal", async ({ack, body, view, client}) => {
    await ack();

    const userId = view.state.values.users_block.selected_users.selected_users;

    const channelID = view.state.values.channel_block.poll_channel.selected_conversation;

    //console.log("****\n\n\n", channelID, "\n", userId, "\n\n\n****")

    for (const uId of userId){
        
        try {
            // Add the user to your system
            await removeUser(channelID, uId);

            // Send confirmation to the person who submitted the modal
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: body.view.private_metadata, // modal owner
                    text: `<@${uId}> has been removed as a member of <#${channelID}>`,
                });
            } catch (error) {
                console.error("***\n\nError posting the removal of a  member:", error, "\n\n***");
            }
        } catch(error) {
        console.error("***\n\nError removing member:", error, "\n\n***");
        }
    }
});

app.command("/pingsubteam", async ({ack, command, client }) => {
    await ack();

    const message     =    command.text.trim();
    const channelID   =    command.channel_id;
    const sender      =    command.user_id;
    const subteam     =    await getUsers(channelID);
    
    console.log("****\n\n\n", message, "\n", channelID, "\n", sender, "\n", subteam, "\n", "\n\n\n****")
    try {
        for (const userID of subteam){
            //const userID = userObj.userID;

            //Invite the user if they're not in the channel
            try {
                await client.conversations.invite({
                channel: channelID,
                users: userID.userID
                });
            } catch (err) {
                if (err.data?.error !== "already_in_channel") {
                    console.error(`Error inviting user ${userID}:`, err.data?.error);
                    continue; // skip this user if invite fails
                }
            }

            //send ping to each user induvidually
            try {
                await client.chat.postEphemeral({
                    channel: channelID,
                    user: userID.userID, // modal owner
                    text: `<@${userID.userID}>`,
                });
            } catch (error) {
                console.error("***\n\nError pinging member:", error, "\n\n***");
            }
        }

        const res = await client.users.info({ user: sender });
        const user = res.user;
        const displayName = user.profile.display_name || user.real_name || "Unknown User";
        const avatarUrl = user.profile.image_192 || user.profile.image_72;

        await client.chat.postMessage({
                    channel: channelID,
                    text: message,
                    username: displayName,
                    icon_url: avatarUrl
        });


    } catch(error) {
       console.error("Error pinging subteam:", error);
    }
});


************************************************************************

export async function addUser(cID, uID) {
    await pool.query(`
        INSERT INTO users (channelID, userID)
        VALUES (?, ?)
        `, [cID, uID])
}

export async function removeUser(cID, uID) {
    await pool.query(`
        DELETE FROM users WHERE channelID = (?) AND userID = (?) 
        `, [cID, uID])
}

export async function getUsers(id) {
    const hi = await pool.query(`
        SELECT userID FROM users WHERE channelID = (?)
        `, [id])
    return hi[0]
}

// export async function getUserRoles(id) {
//     const hi = await pool.query(`
//         SELECT channelID FROM users WHERE userID = (?)
//         `, [id])
//     return hi[0]
// }


*************************************************************88