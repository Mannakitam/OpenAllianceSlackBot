//clickup API stuff
import dotenv from "dotenv"
import { readFile,writeFile } from 'node:fs/promises';

dotenv.config()


const url = "https://api.clickup.com/api/v2/team/9011117189/task";
const options = {
    method: 'GET', 
    headers: {
        accept: 'application/json',
        Authorization: process.env.CLICKUP_API_KEY

    }};


function cacheClickUpData() {
    fetch(url, options)
        .then(res => res.json())
        .then(json => {
            console.log('Data saved');
            writeFile('./temp.json', JSON.stringify(json, null, 2));
        })
        .catch(err => console.error(err)); 
}

const data = await readFile('./temp.json', 'utf8');
const json = JSON.parse(data);

console.log(json);

//Command to create poll
// app.command("/whoscoming", async ({ command, ack, client }) => {
    //   await ack();

    //   const dateInput = command.text.trim();
    //   const channelId = command.channel_id;

    //   try {

        //     //try to join channel if not in (so you dont have to invite every time)
        //     try {
            //       await client.conversations.join({ channel: channelId });
            //       console.log(`Joined channel ${channelId}`);
            //     } catch (joinError) {
                //       if (joinError.data?.error !== "method_not_supported_for_channel_type") {
                    //         console.warn(`Could not auto-join channel ${channelId}:`, joinError.data?.error);
                    //       }
                //     }

        //     const meetings = loadMeetings();

        //     // Ensure channel entry exists
        //     if (!meetings[channelId]) meetings[channelId] = [];

        //     const newDate = new Date(dateInput);

        //     //Check for existing meeting with same date
        //     const existingMeeting = meetings[channelId].find(
            //       (m) => new Date(m.date).toDateString() === newDate.toDateString()
            //     );

        //     if (existingMeeting) {
            //       await client.chat.postEphemeral({
                //         channel: channelId,
                //         user: command.user_id,
                //         text: `A meeting poll already exists for *${dateInput}*`,
                //       });
            //       console.log(1)
            //       return;
            //     }
        //       const showDate = new Date(dateInput).toDateString()
        //       // 1. Post poll message
        //       const result = await client.chat.postMessage({
            //         channel: channelId,
            //         text: `<!channel> Who is going to the meeting on *${showDate}*? React with âœ… or âŒ`,
            //       });

        //       // 2. Add reactions
        //       await client.reactions.add({ channel: result.channel, timestamp: result.ts, name: "white_check_mark" });
        //       await client.reactions.add({ channel: result.channel, timestamp: result.ts, name: "x" });

        //       // 3. Save poll to JSON
        //       if (!meetings[channelId]) meetings[channelId] = [];

        //       meetings[channelId].push({
            //         ts: result.ts,
            //         date: dateInput,
            //       });
        //       saveMeetings(meetings);


        //       await client.chat.postEphemeral({
            //         channel: channelId,
            //         user: command.user_id,
            //         text: `Meeting poll created and saved for *${dateInput}*`,
            //       });
        //   }
    //   catch (error) {
        //     console.error("Error posting testreport:", error);
        //   }
    // });




    // Schedule the daily report at 9:30 PM

// cron.schedule('28 20 * * *', async () => {
    //   console.log('9:30 PM - Triggering daily report...');
    //   await sendDailyReport();
    // }, {
        //   timezone: "America/New_York" // Change to your timezone
        // });

// // message leads asking them for photos and videos, add to a Google drive folder
// cron.schedule('17 00 * * *', async() => {
    //   await pm(process.env.SLACK_USER_IDS, `Please add any photos or videos from todays meeting to <${process.env.GOOGLE_DRIVE_LINK}| google drive>`);
    // },{
        //   timezone: "America/New_York" //timezone
        // });


// Function to format and send the daily report
async function sendDailyReport() {
    try {
        const reportData = await generateDailyReport();

        if (reportData.status === 'error') {
            // Send error message
            await app.client.chat.postMessage({
                token: process.env.SLACK_BOT_TOKEN,
                channel: DAILY_REPORT_CHANNEL,
                text: 'âš ï¸ Daily Report - Service Issue',
                blocks: [
                    {
                        type: 'header',
                        text: {
                            type: 'plain_text',
                            text: 'âš ï¸ Daily Report - Service Issue'
                        }
                    },
                    {
                        type: 'section',
                        text: {
                            type: 'mrkdwn',
                            text: `*Time:* ${reportData.timestamp}\n*Status:* ${reportData.message}`
                        }
                    }
                ]
            });
            return;
        }

        // Create rich formatted message with both API results
        const blocks = [
            {
                type: 'header',
                text: {
                    type: 'plain_text',
                    text: 'ðŸ“Š Daily Data Report - 9:30 PM Update'
                }
            },
            {
                type: 'context',
                elements: [
                    {
                        type: 'mrkdwn',
                        text: `ðŸ“… Generated on ${reportData.timestamp}`
                    }
                ]
            },
            {
                type: 'divider'
            }
        ];


        // Add AI Analysis section
        blocks.push({
            type: 'section',
            text: {
                type: 'mrkdwn',
                text: `ðŸ¤– *AI Analysis (${reportData.aiAnalysis.model})*\n${reportData.aiAnalysis.analysis}`
            }
        });



        // Add footer
        blocks.push(
            {
                type: 'divider'
            },
            {
                type: 'context',
                elements: [
                    {
                        type: 'mrkdwn',
                        text: 'Automated report Generated every day at 9:30 PM'
                    }
                ]
            }
        );



        // Send the formatted message
        await app.client.chat.postMessage({
            token: process.env.SLACK_BOT_TOKEN,
            channel: DAILY_REPORT_CHANNEL,
            text: 'ðŸ“Š Daily Data Report - 9:30 PM Update',
            blocks: blocks
        });

        console.log('âœ… Daily report sent successfully to Slack');

    } catch (error) {
        console.error('âŒ Error sending daily report:', error);

        // Send fallback message
        await app.client.chat.postMessage({
            token: process.env.SLACK_BOT_TOKEN,
            channel: DAILY_REPORT_CHANNEL,
            text: 'âš ï¸ Daily report failed to send. Please check the bot logs.'
        });
    }
}



app.command("/clearmeetings", async ({ command, ack, client }) => {
    await ack();

    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        if (!meetings[channelId]) meetings[channelId] = [];

        meetings[channelId] = [];
        saveMeetings(meetings);
    } catch (error) {
        console.error("Error clearing meetings:", error);
    }
});




app.command("/meetingreport", async ({ command, ack, client }) => {
    await ack();

    const dateInput = command.text.trim();
    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        const channelMeetings = meetings[channelId] || [];

        //No date provided â†’ show available poll dates
        if (!dateInput) {
            if (channelMeetings.length === 0) {
                await client.chat.postEphemeral({
                    channel: channelId,
                    user: command.user_id,
                    text: `There are no meeting polls saved in this channel.`,
                });
                return;
            }

            const datesList = channelMeetings.map(m => `â€¢ ${m.date}`).join("\n");

            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `*Available meeting reports in this channel:*\n${datesList}\n\nRun \`/meetingreport <date>\` to view one.`,
            });

            return;
        }

        //Date provided â†’ find that poll
        const meeting = channelMeetings.find(m => m.date === dateInput);
        if (!meeting) {
            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `âŒ No meeting poll found for *${dateInput}* in this channel.`,
            });
            return;
        }

        const auth = await client.auth.test();
        const botUserId = auth.user_id;

        const response = await client.reactions.get({
            channel: channelId,
            timestamp: meeting.ts,
        });

        const reactions = response.message.reactions || [];
        const yesReaction = reactions.find(r => r.name === "white_check_mark");
        const noReaction = reactions.find(r => r.name === "x");

        const yesUsers = yesReaction
            ? yesReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        const noUsers = noReaction
            ? noReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        client.chat.postEphemeral({
            channel: channelId,
            user: command.user_id,
            text: `*Meeting Report for ${meeting.date}*\nâœ… Coming: ${yesUsers.length ? yesUsers.join(", ") : "None"}\nâŒ Not coming: ${noUsers.length ? noUsers.join(", ") : "None"}`,
        });

    } catch (error) {
        console.error("Error getting report:", error);
    }
});


app.command("/latestmeeting", async ({ command, ack, client }) => {
    await ack();

    const channelId = command.channel_id;

    try {
        const meetings = loadMeetings();
        const channelMeetings = meetings[channelId] || [];


        let date = new Date(channelMeetings[0].date);;
        let index = 0;
        for(let i = 0; i < channelMeetings.length; i++) {
            let nDate = new Date(channelMeetings[i].date);
            if(nDate > date){
                index = i;
                date = nDate;
            }
        }


        // ðŸ“Š Date provided â†’ find that poll
        const meeting = channelMeetings[index];
        if (!meeting) {
            await client.chat.postEphemeral({
                channel: channelId,
                user: command.user_id,
                text: `âŒ No meeting poll found for *${dateInput}* in this channel.`,
            });
            return;
        }

        const auth = await client.auth.test();
        const botUserId = auth.user_id;

        const response = await client.reactions.get({
            channel: channelId,
            timestamp: meeting.ts,
        });

        const reactions = response.message.reactions || [];
        const yesReaction = reactions.find(r => r.name === "white_check_mark");
        const noReaction = reactions.find(r => r.name === "x");

        const yesUsers = yesReaction
            ? yesReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        const noUsers = noReaction
            ? noReaction.users.filter(u => u !== botUserId).map(u => `<@${u}>`)
            : [];

        client.chat.postEphemeral({
            channel: channelId,
            user: command.user_id,
            text: `*Meeting Report for ${meeting.date}*\nâœ… Coming: ${yesUsers.length ? yesUsers.join(", ") : "None"}\nâŒ Not coming: ${noUsers.length ? noUsers.join(", ") : "None"}`,
        });

    } catch (error) {
        console.error("Error getting report:", error);
    }
});

app.command("/addlead", async ({command, ack, client}) => {
    await ack();

    const userID = command.text.trim();
    console.log(userID)
    // Match all user mentions â€” handles both "<@U12345>" and "<@U12345|username>"
    const userMatches = userID.matchAll(/<@([A-Z0-9]+)(?:\|[^>]+)?>/gi);

    // Convert to an array of user IDs
    const mentionedUserIds = Array.from(userMatches, m => m[1]);
    console.log(mentionedUserIds)

    if (mentionedUserIds.length === 0) {
        await client.chat.postEphemeral({
            channel: command.channel_id,
            user: command.user_id,
            text: "Please mention at least one user like `/addlead @username`",
        });
    }

    const channelId = command.channel_id;

    try {

        const leads = loadLeads();

        console.log("\n\n\n1\n\n\n")

        const result = await app.client.users.list();
        const users = result.members;

        for(let id of mentionedUserIds){
            if (!leads[id]) leads[id] = [];

            console.log(id + "\n")
            console.log(leads)
            users.forEach(u => {
                if(id == u.id) {
                    leads[id].push([u.real_name]);
                }  
            })
        }
        saveLeads(leads);
    } catch (error) {
        console.error("Error adding leads:", error);
    }

});


const MEETINGS_FILE = "./meetings.json";
const LEADS_FILE = "./leads.json"

// Utility: load JSON
function loadMeetings() {
    if (!fs.existsSync(MEETINGS_FILE)) return {};
    const data = fs.readFileSync(MEETINGS_FILE);
    return JSON.parse(data);
}

// Utility: save JSON
function saveMeetings(meetings) {
    fs.writeFileSync(MEETINGS_FILE, JSON.stringify(meetings, null, 2));
}

// Utility: load JSON
function loadLeads() {
    if (!fs.existsSync(LEADS_FILE)) return {};
    const data = fs.readFileSync(LEADS_FILE);
    return JSON.parse(data);
}

// Utility: save JSON
function saveLeads(leads) {
    fs.writeFileSync(LEADS_FILE, JSON.stringify(leads, null, 2));
}

